## 基础规定和语法
### Java 常量
常量在程序运行时是不能被修改的。
在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：
```java
final double PI = 3.1415927;
```
### JSR JCP 是啥

* JSR规范：`Java Specification Request`
* JCP组织：`Java Community Process`
为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。
### 布尔运算   
布尔运算的一个重要特点是短路运算


布尔运算是一种关系运算，包括以下几类：

* 比较运算符：>，>=，<，<=，==，!=
* 与运算 &&
* 或运算 ||
* 非运算 !
`关系运算符的优先级从高到低依次是：`

!
>，>=，<，<=
==，!=
&&
||
### 字符和字符串
在Java中，字符和字符串是两个不同的类型。

字符类型
字符类型char是基本数据类型，它是character的缩写。一个char保存一个Unicode字符：
### 字符串连接
Java的编译器对字符串做了特殊照顾，可以使用+连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如：

`如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接`

### 从Java 13开始，字符串可以用"""..."""表示多行字符串（Text Blocks）了

### 数组变量
定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组。

Java的数组有几个特点：

数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false；
数组一旦创建后，大小就不可改变。
要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4。

可以修改数组中的某一个元素，使用赋值语句，例如，ns[1] = 79;

### Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：

占位符	说明
%d	格式化输出整数
%x	格式化输出十六进制整数
%f	格式化输出浮点数
%e	格式化输出科学计数法表示的浮点数
%s	格式化字符串
注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身

###  要判断引用类型的变量内容是否相等，必须使用equals()方法
对于多个==判断的情况，使用switch结构更加清晰。
### while循环语句就是让计算机根据条件做循环计算，在条件满足时继续循环，条件不满足时退出循环。
### 在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是
### 冒泡排序
### 命令行參數
Java程序的入口是main方法，而main方法可以接受一个命令行参数，它是一个String[]数组。
### JAVA 字符的方法
#### 用StringJoiner的结果少了前面的"Hello "和结尾的"!"！遇到这种情况，需要给StringJoiner指定“开头”和“结尾” （这个内置方法，可以去头尾）
### 为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类：
### Math 类
顾名思义，Math类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：

----------------------------
###  Lambad  (兰布达) 希娜字母的11
Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。

Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。

使用 Lambda 表达式可以使代码变的更加简洁紧凑
 使用 Lambda 表达式需要注意以下两点：

    Lambda 表达式主要用来定义行内执行的方法类型接口（例如，一个简单方法接口）。在上面例子中，我们使用各种类型的 Lambda 表达式来定义 MathOperation 接口的方法，然后我们定义了 operation 的执行。

    Lambda 表达式免去了使用匿名方法的麻烦，并且给予 Java 简单但是强大的函数化的编程能力

### 多态

什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。  

多态存在的三个必要条件
继承
重写
父类引用指向子类对象：Parent p = new Child();
虚函数
虚函数的存在是为了多态
当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。

要想调用父类中被重写的方法，则必须使用关键字 super


## 继承 inherit

继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 Object（这个类在 java.lang 包中，所以不需要 import）祖先类。
extends 继承类， implements  实现接口

### 重写 Override

重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。
在面向对象原则里，重写意味着可以重写任何现有方法
> 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
  子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。   
   重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常


当需要在子类中调用父类的被重写方法时，要使用 super 关键字。

### 重载(Overload)
重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载

* 方法重载(Overloading)：如果有两个方法的方法名相同，但参数不一致，哪么可以说一个方法是另一个方法的重载。
* 方法覆盖（Overriding）：如果在子类中定义一个方法，其名称、返回类型及参数签名正好与父类中某个方法的名称、返回类型及参数签名相匹配，那么可以说，子类的方法覆盖了父类的方法。

###  抽象类

在面向对象中，所有的对象都是通过类来描述的，但是反过来，并不是所有的类都可以用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就叫做抽象类
由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用！一个类可以实现多个接口
引入抽象方法和抽象类，是Java提供的一种语法工具，对于一些类和方法，引导使用者正确使用它们，减少被误用。

### 封装  Encapsulation

封装是指将一种抽象性函式接口的实现细节部分包装，隐藏起来的方法



## 接口  interface 

接口的特性：
* 接口是隐式抽象的，当声明一个接口的时候，可以不使用abstract 关键字
* 接口中 的每一个方法都是隐式的抽象的，声明时不需要关键字abstract 
* 接口中的方法都是公有的


## 枚举 enum
枚举是一个特殊的类，一般表示一组常量，比如四季，12个月，星期几


枚举跟普通类一样可以使用自己的变量，方法和构造函数， 构造函数只能使用private 访问修饰符，所以外部无法访问




### 包 package
为了区别类名的命名空间

* 把功能相似的或者相关的类或接口组织在同一个包中，方便类的查找和使用
* 同一个文件夹，包采用树型目录存储方式
* 包也限定了访问权限，拥有包权限的类才能访问某个包中的类

创建包
通常使用小写字母来命名，避免与类，接口名字的冲突

### 构造函数，
是一种特殊的函数，与函数名称相同，无返回值
一般使用初始化成员的属性和方法，即Nes 对象后，就调用了对象的属性和方法

具有参数的构造函数 称为参数化构造函数

### java 的数据结构
* 枚举 Emumeration
* 位集合  Bitsit
* 向量  Vector     Vector.sort 方法对向量进行排序
* 栈 stack
* 字典 Dictionary    

  字典就是有个抽象类，它定义了键映射到值的数据结构
* 哈希表 Hashtable
* 属性 Properties

## 数据结构
#### Linkedlist 线性表
类似于 Arraylist  是一种重圆的数据容器

以下情况使用Linkedlist
* 需要通过循环迭代来访问列表中的某些元素
* 需要频繁的在列表开头，中间，结尾处进行刷出元素操作等

#### HashSet 
HashSet 基于HashMap 来实现的，是一个不允许有重复元素的集合


#### iterator 迭代器
iterator  不是一个集合，它是一种用于访问集合方法，可用于迭代Arraylist 和  HashSet

#### 泛型  generics  泛型提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型

### socket 通信
JDBC 内部底层其实是socket 通信
##

### 调用另一个文件的类
 在java里怎么在一个java程序里调用运行另一个java类?
先把2个文件放在同一个包下面，这样就可以访问另一个java程序了。

java怎么调用另一个类的方法
java类有两种方法一种是类方法就是用static修饰的，   一种是实例方法，就是没有static修饰的方法。类方法可以同时类名.方法名的方式调用。
>用静态公有方法的语法是：类名.方法名(参数...);
 所以，比如另一个类叫OtherClass，它的静态公有方法是 public static int MethodA() {...}    

> 那么在你自己的类里调用的方式就是：int result = OtherClass.MethodA();
 另外，调用非静态公有方法（也叫成员方法），比如方法叫 public int MethodB() {...}
 就必须先创建这个类的对象再调用其方法，
 例如：int result2 = new OtherClass().MethodB();

```
 在Java中，静态方法是属于类而不是对象的方法。它们可以直接通过类名调用，而无需创建类的实例。静态方法有以下几个常见的用途和优势：

1. 工具方法：静态方法通常用于实现一些通用的功能，例如数学计算、字符串处理等。由于它们不依赖于特定的对象状态，因此可以直接通过类名调用，方便使用。

2. 简化代码：静态方法可以在不创建对象的情况下执行操作，这样可以避免创建不必要的对象。这对于一些简单的操作或者不需要访问对象状态的方法来说，可以提高代码的简洁性和执行效率。

3. 共享数据：静态方法可以访问和修改静态变量，这些变量在类的所有实例之间是共享的。这使得静态方法可以用于处理和操作共享数据，而不需要每个实例都保存一份副本。

4. 工厂方法：静态方法可以用于创建对象实例，这种模式被称为工厂方法模式。通过在静态方法中封装对象的创建逻辑，可以提供更灵活的对象创建方式，同时隐藏具体的实现细节。

需要注意的是，静态方法不能直接访问非静态成员（例如实例变量和实例方法），因为它们没有隐式的this引用。此外，静态方法不能被子类重写，因为它们属于类而不是对象。
总而言之，静态方法在Java中具有一些特殊的用途和优势，可以提供更简洁、高效和灵活的代码实现方式。然而，过度使用静态方法可能导致代码难以测试和维护，因此应该根据具体的需求和设计原则来合理使用
```

在Java中，与类名相同的方法被称为构造方法（Constructor）。构造方法是一种特殊的方法，用于创建和初始化对象。构造方法的名称必须与类名完全相同，并且没有返回类型（包括void）。构造方法在创建对象时自动调用，并且可以用于执行必要的初始化操作

### set是一种常见的命名约定，用于设置对象的属性或配置。它通常用于通过方法调用来设置对象的属性值  
 使用set方法的好处是它提供了一种统一的方式来设置对象的属性或配置，使代码更易读和维护。此外，set方法还可以提供一些额外的逻辑，例如验证输入值的有效性或触发其他操作。