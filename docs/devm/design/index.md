<!-- 设计模式的使用 -->
      设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。
什么是设计模式    

> 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。
计模式基本上有23种类型。按照主要分类可以分为三大类:
设计模式的原则
设计模式的六大原则

* 开闭原则：对扩展开放，对修改关闭。
* 里氏代换原则：对开闭原则的补充。任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。
* 依赖倒转原则：针对接口编程，依赖于抽象而不依赖于具体。
* 接口隔离原则：尽量使用多个隔离的接口，为了降低类之间的耦合度。
* 迪米特法则：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
* 合成复用原则：尽量使用合成/聚合的方式，而不是使用继承。

### 主要设计模式

* 创建型模式
    1. 工厂方法
    2. 抽象工厂
    3. 生成器
    4. 原型
    5. 单例
* 结构型模式  
    * 适配器
    * 桥接
    * 组合

* 行为型模式
    * 观察者模式
    * 访问者
    * 策略
### 行为型模式
#### 责任链
 责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：   

    在实际场景中，财务审批就是一个责任链模式
        用责任链模式设计此报销流程时，每个审核者只关心自己责任范围内的请求，并且处理它。对于超出自己责任范围的，    
        扔给下一个审核者处理，这样，将来继续添加审核者的时候，不用改动现有逻辑。
#### 命令
> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。




#### 解释器模式（Interpreter）
解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活






#### 中介模式
> 用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
中介模式（Mediator）又称调停者模式，它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。

#### 备忘录
> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
在使用文本编辑器的时候，我们还经常使用Undo、Redo这些功能。这些其实也可以用备忘录模式实现，即不定期地把TextEditor类的字符串复制一份存起来，这样就可以Undo或Redo

#### 观察者模式
> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。
#### 策略模式
> 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法
使用到了策略模式，它实际上指，在一个方法中，流程是确定的，但是，某些关键步骤的算法依赖调用方传入的策略，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。
使用场景： 购物车中 不同会员的折扣

#### 模板方法
> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
#### 访问者模式
> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作
### 